<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="I Kadek Nova Arta Kusuma">

<title>Clustering local authorities by road collision patterns</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="coursework_unsupervised_files/libs/clipboard/clipboard.min.js"></script>
<script src="coursework_unsupervised_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="coursework_unsupervised_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="coursework_unsupervised_files/libs/quarto-html/popper.min.js"></script>
<script src="coursework_unsupervised_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="coursework_unsupervised_files/libs/quarto-html/anchor.min.js"></script>
<link href="coursework_unsupervised_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="coursework_unsupervised_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="coursework_unsupervised_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="coursework_unsupervised_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="coursework_unsupervised_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Clustering local authorities by road collision patterns</h1>
<p class="subtitle lead">Student Number: 740098736</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>I Kadek Nova Arta Kusuma </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Road traffic collisions differ widely between local authorities because of factors such as urbanisation, traffic levels, weather, and lighting conditions. To understand these patterns more clearly, an unsupervised learning approach is useful, as it allows us to identify groups of areas with similar collision characteristics without using any prior labels. This study applies three clustering methods—Hierarchical Clustering, K-Means, and Gaussian Mixture Models (GMM)—to reveal the natural structure in the collision data and group local authorities in a meaningful way. With PCA used for visualisation, the clustering results help us see how risks vary across regions and support more targeted road-safety strategies.</p>
</section>
<section id="the-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-problem">The Problem</h2>
<p>Patterns of road traffic collisions vary across local authorities due to differences in urbanisation, weather, lighting, and road conditions. This study uses key variables such as the total number of collisions (n_total), the proportion of collisions in rain (n_raining), in darkness (n_dark), on dry roads (n_dry), the level of urbanisation (n_urban), the proportion of slight injuries (n_slight), and the number of mini roundabouts (n_miniroundabouts) to describe these differences. Because these variables interact in complex ways, the patterns are difficult to identify manually.</p>
<p>The aim of this study is to determine whether natural clusters exist based on these collision characteristics and to understand the factors that distinguish each cluster. To achieve this, three unsupervised learning methods are applied: Hierarchical Clustering (to explore the structure of the groupings), K-Means (to identify representative centroids), and Gaussian Mixture Models (GMM) (to allow a more flexible, probabilistic approach). PCA is used to visualise the clusters in a lower-dimensional space. Together, these methods provide a clearer understanding of collision patterns across regions and support the development of more targeted road-safety policies.</p>
</section>
<section id="exploratory-data-analysis" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-data-analysis">Exploratory Data Analysis</h2>
<p>From the scatter plots between features, several patterns become noticeable. For example, the plot of n_total against n_urban shows that areas with higher urbanisation tend to have more collisions, while less urbanised areas usually have fewer. The plot of n_raining versus n_dry shows an opposite trend, where regions with more rainfall tend to have fewer dry-road conditions. Meanwhile, the plot of n_dry versus n_slight suggests that slight injuries occur more frequently when the road is dry.</p>
<p>Other scatter plots also highlight variation between features. For instance, n_miniroundabouts appears to have a different distribution compared with the other variables, and n_dark shows a wide range of values without forming a strong linear pattern with most features. These visual patterns give early clues about which factors may separate groups in the data.</p>
<p>Based on these observations, some features—especially n_total, n_urban, n_raining, and n_dry—seem particularly informative for clustering because they show clearer differences across data points. These initial insights motivate the use of unsupervised methods such as Hierarchical Clustering, K-Means, or Gaussian Mixture Models to identify meaningful groups of collision patterns in the dataset.</p>
<p><embed src="../../data_cache/vignettes/unsupervised_classification/scatterplot.html" style="width:100.0%" height="600"></p>
</section>
<section id="determining-the-number-of-clusters-k" class="level2">
<h2 class="anchored" data-anchor-id="determining-the-number-of-clusters-k">Determining the Number of Clusters (K)</h2>
<p>K-means metrics: Elbow Score <embed src="../../data_cache/vignettes/unsupervised_classification/kmeans_elbow.html" style="width:100.0%" height="600"> Silhouette Score <embed src="../../data_cache/vignettes/unsupervised_classification/kmeans_silhouette.html" style="width:100.0%" height="600"> BIC/AIC <embed src="../../data_cache/vignettes/unsupervised_classification/gmm_bic_aic.html" style="width:100.0%" height="600"> Based on the three methods used to determine the number of clusters, the results are fairly consistent in showing that the most stable structure in the data appears at three clusters. In the elbow plot, the largest drop in WSS occurs up to k = 3, after which the curve begins to flatten, indicating that adding more clusters provides little additional benefit. The silhouette score is indeed highest at k = 2, but k = 3 still performs well and captures more variation in collision patterns across local authorities.</p>
<p>The GMM analysis using BIC/AIC also suggests that models with three or four components are the most efficient, with the lowest values typically appearing around k = 3. Overall, all three approaches point to k = 3 as the most balanced choice, offering clear separation between clusters without introducing unnecessary model complexity.</p>
</section>
<section id="clustering" class="level2">
<h2 class="anchored" data-anchor-id="clustering">Clustering</h2>
<section id="hierarchical-clustering" class="level3">
<h3 class="anchored" data-anchor-id="hierarchical-clustering">Hierarchical Clustering</h3>
<p>The first task is to perform hierarchical clustering.</p>
<p><embed src="../../data_cache/vignettes/unsupervised_classification/dendrogram.html" style="width:100.0%" height="600"></p>
<p>The dendrogram shows that the most stable clustering structure appears when the cut is made at a height of around 20–25, which produces three main clusters—matching the three colour groups in the plot. At this level, the major branches separate clearly, so the resulting clusters can be interpreted as distinct groups.</p>
<p>If the cut is made lower, for example at a height of 10–15, the number of clusters increases to around five to seven because the larger groups begin to split into smaller sub-clusters. Cutting even further down, around height 5, produces more than ten clusters as even very similar observations are separated into small groups. However, choosing a height that is too low leads to over-segmentation, where meaningful groups are broken into clusters that are too small and no longer interpretable.</p>
<p>For this reason, selecting a height of around 20–25 provides the best balance between having a manageable number of clusters and preserving the meaningful structural patterns in the data.</p>
<p><embed src="../../data_cache/vignettes/unsupervised_classification/hscatter.html" style="width:100.0%" height="600"></p>
<p>Hierarchical clustering using Ward’s method produces three main groups when the dendrogram is cut at a height of around 22. This level is chosen because it marks a large jump in the merging distance, indicating that the three resulting clusters represent a stable natural structure in the data. PCA visualisation shows that the three clusters separate reasonably well, reflecting meaningful differences in collision characteristics across the groups.</p>
<p>Based on the summary statistics, Cluster 1 contains local authorities with the lowest collision levels and relatively light traffic conditions. Cluster 2 represents areas with medium collision patterns and no extreme characteristics, making it a kind of “average” group. Cluster 3, in contrast, consists of authorities with the highest collision levels, marked by high values in urban conditions, rain, and darkness—indicating areas with heavier traffic and greater accident risk.</p>
<p>Overall, the hierarchical clustering results form a clear and interpretable structure, providing a strong foundation for comparison with K-Means and Gaussian Mixture Models in the subsequent analysis.</p>
</section>
<section id="k-means-clustering" class="level3">
<h3 class="anchored" data-anchor-id="k-means-clustering">K-Means Clustering</h3>
<p>####Centroid <embed src="../../data_cache/vignettes/unsupervised_classification/kcentroids1.html" style="width:100.0%" height="600"> <embed src="../../data_cache/vignettes/unsupervised_classification/kcentroids2.html" style="width:100.0%" height="600"></p>
<p>The local authority dataset was analysed using K-Means with four clusters. The cluster sizes vary: Cluster 3 is the largest (n ≈ 1,497), Cluster 2 is the smallest (n ≈ 359), while Clusters 0 and 1 fall in the medium range.</p>
<p>The cluster centroids reveal three main collision patterns. Cluster 1 represents the most urban and highest-risk areas, with the highest n_total (around 1200), a high urban proportion (0.81), a large share of dry-road collisions (0.89), and a high proportion of slight injuries (0.81). Cluster 0 sits in the middle range, with n_total around 450, fairly high urbanisation (0.72), and frequent slight-injury collisions (0.74), indicating semi-urban conditions.</p>
<p>Cluster 2 has the lowest n_total (around 300), low urbanisation (0.45), fewer slight-injury collisions (0.64), and relatively higher proportions of collisions in rain and darkness, which suggests more rural characteristics. Overall, the main differences between these clusters are driven by levels of urbanisation and collision volume.</p>
<section id="k-means-scatterplot" class="level4">
<h4 class="anchored" data-anchor-id="k-means-scatterplot">K-Means Scatterplot</h4>
<p><embed src="../../data_cache/vignettes/unsupervised_classification/kscatter.html" style="width:100.0%" height="600"></p>
<p>The PCA scatter plot shows that the three K-Means clusters form reasonably distinct groups, with Cluster 1 separated most clearly from the others. This matches the centroid summary, where Cluster 1 has a much higher n_total (around 1200) and higher proportions of urban areas, dry-road collisions, and slight injuries, indicating high-risk urban authorities. Cluster 0 has moderate values across most variables (n_total around 450; urbanisation around 0.72), placing it near the centre of the plot and representing semi-urban areas with medium risk. Cluster 2 shows the lowest n_total (around 300), low urbanisation (around 0.45), and slightly higher proportions of collisions in rain or darkness, forming a separate group that reflects lower-risk rural areas. Overall, the patterns suggest that traffic intensity and urbanisation are the main factors distinguishing the clusters.</p>
</section>
</section>
<section id="gmm-clustering" class="level3">
<h3 class="anchored" data-anchor-id="gmm-clustering">GMM-clustering</h3>
<p><embed src="../../data_cache/vignettes/unsupervised_classification/gmm_scatter.html" style="width:100.0%" height="600"></p>
<p>The PCA scatter plot for the GMM results shows three groups that form more gradually compared with K-Means, since GMM assigns clusters based on probabilities rather than strict boundaries. The centroid summary indicates that Cluster 1 has the highest collision intensity, with the largest n_total and high proportions of urban, dry-road, and slight-injury collisions, reflecting dense urban areas. Cluster 0 shows moderate values across all variables and represents semi-urban regions with medium risk. Cluster 2 has the lowest n_total, low urban proportions, and a tendency toward more collisions in rain or darkness, indicating low-traffic rural areas. Overall, GMM identifies cluster patterns that are consistent with the previous methods, with the main difference being the smoother, more gradual separation between groups.</p>
</section>
</section>
<section id="disscussion-and-conclusion" class="level2">
<h2 class="anchored" data-anchor-id="disscussion-and-conclusion">Disscussion and Conclusion</h2>
<p>The three clustering methods—Hierarchical Clustering (Ward), K-Means, and Gaussian Mixture Models (GMM)—consistently reveal a three-cluster structure in the local authority collision data. Although each approach works differently, the patterns that appear are very similar: one cluster with high collision levels and strongly urban characteristics, one with medium intensity and semi-urban features, and one with low collision levels that reflects more rural areas.</p>
<p>Hierarchical clustering provides the most intuitive view of how groups form step by step, and cutting the dendrogram at height 22 produces three clusters that make sense both visually and statistically. K-Means supports this result by giving clearly separated centroids, especially for the urban variable, total collisions, and weather-related conditions. GMM, meanwhile, produces smoother and more realistic boundaries because it assigns points based on probability, which is helpful when clusters overlap in PCA space. The fact that all three methods identify the same overall structure suggests that the data contain a strong and stable clustering pattern that is not dependent on any particular algorithm. GMM adds flexibility in capturing gradual transitions, while K-Means remains the easiest to interpret through its centroids.</p>
<p>Across the three methods, the dataset consistently splits into three main groups that reflect clear differences in urbanisation levels, collision intensity, and environmental conditions at the time of the accidents. The first cluster represents high-risk urban areas with large numbers of collisions and a dominance of slight injuries on dry roads. The second cluster captures semi-urban regions with moderate and more balanced collision patterns. The third cluster consists of rural areas where collision numbers are low but more affected by weather and darkness. The agreement across methods shows that the three-cluster structure is reliable and meaningful. This clustering framework can therefore support more targeted road-safety policies, such as traffic-management improvements in dense urban areas and weather-related risk mitigation in rural regions.</p>
</section>
<section id="record-of-ai-use-for-mthm503-unsupervised-coursework" class="level2">
<h2 class="anchored" data-anchor-id="record-of-ai-use-for-mthm503-unsupervised-coursework">Record of AI use for MTHM503 unsupervised coursework</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 9%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 21%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Date</strong></th>
<th><strong>AI tool used</strong></th>
<th><strong>Purpose</strong></th>
<th><strong>Prompt</strong></th>
<th><strong>Hyperlink to output (where possible)</strong></th>
<th><strong>Section of work used for</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E.g. 15/07/2025</td>
<td>MS Copilot</td>
<td>To help create an organised essay structure</td>
<td>‘Generate ideas for structuring an essay on…’</td>
<td>[insert link]</td>
<td>introduction</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>